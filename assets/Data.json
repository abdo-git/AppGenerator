{
  "name": "algorithme",
  "tags": [
    {
      "id": "00MgmRAugeBGq3QL3pZA",
      "libelle": "tas"
    },
    {
      "id": "3K9gsODPePO5B2jjrl3P",
      "libelle": "tri"
    },
    {
      "id": "B0hdgMJeAL0EMzs6Vgua",
      "libelle": "complexite"
    },
    {
      "id": "CyxU2MpGRo7XZAuUsMhG",
      "libelle": "file"
    },
    {
      "id": "IUlcrbn3fXnKgjJWeyhV",
      "libelle": "arbre"
    },
    {
      "id": "TeLVR7CvcaA3oj3TbYzf",
      "libelle": "pointeur"
    },
    {
      "id": "VHpNe29l62dHAmbfC2eR",
      "libelle": "tag"
    },
    {
      "id": "gYkj13NGaBdrl8TNJg31",
      "libelle": "pile"
    },
    {
      "id": "jZ86ZD6nOxN6lkSOXOZ8",
      "libelle": "hachage"
    },
    {
      "id": "vDaTMVmYliI15e4fkVWK",
      "libelle": "liste chainé"
    }
  ],
  "onglets": [
    {
      "idOnlget": 2,
      "ongletName": "exercice d'application",
      "chapters": [
        {
          "id": "5Re8IJFcazMZJrvIC2mz",
          "idOnglet": 2,
          "tags": [],
          "volumeHoraire": "2",
          "titre": "recursivité",
          "contenu": "<p><strong>Exercice 1 : </strong><i>Complexité des algorithmes&nbsp;</i><br>&nbsp;</p><p>Pour les algorithmes suivant, les quels terminent correctement<br><strong>Algorithm 15:&nbsp;</strong><i>Fonction 1&nbsp;</i><br>&nbsp;</p><blockquote><p>Data : entier $n$</p><p>Result : entier $resultat$</p><p>if $n = 0$ then</p><p>return $0$;</p><p>else</p><p>return $function1(n+1)$</p><p>end if</p></blockquote><p><strong>Algorithm 16:&nbsp;</strong><i>Fonction 2&nbsp;</i></p><blockquote><p>&nbsp;Data : entier $n$</p><p>Result : entier $resultat$</p><p>if $n = 0$ then</p><p>return $0$;</p><p>else</p><p>$resultat ← function2(n−1)$;</p><p>$resultat ← resultat+n$;</p><p>return $resultat$;</p><p>end if</p></blockquote><p><strong>Algorithm 17:&nbsp;</strong><i>Fonction 3&nbsp;</i></p><blockquote><p>&nbsp;Data : entier $n$</p><p>Result : entier $resultat$</p><p>if $n≤1$ then</p><p>return $1$;</p><p>else</p><p>return $1 + function3(n−2)$;</p><p>end if</p></blockquote><p><strong>Exercice 2 : </strong><i>Somme d’une série</i></p><p>Écrire une fonction en langage algorithmique qui prend en paramètre un entier $i$ et calcule la valeur $u(i)$ déﬁnie par récurrence par: $u(0) = 1$ et $u(1) = 2$ $u(n) = 3∗u(n)−u(n−1)$</p><p>Donnez une version itérative de cette fonction et comparez la complexité des deux versions.<br>&nbsp;</p>",
          "niveau": "4",
          "idCours": "56lW22p1RMMd49td9cHD"
        },
        {
          "id": "jmcoCZwUDq5ZnVXMdqFN",
          "volumeHoraire": "1",
          "tags": [
            {
              "libelle": "pointeur",
              "id": "TeLVR7CvcaA3oj3TbYzf"
            },
            {
              "libelle": "tri",
              "id": "3K9gsODPePO5B2jjrl3P"
            }
          ],
          "idCours": "56lW22p1RMMd49td9cHD",
          "contenu": "<p><strong>Exercice 1 : </strong><i>Complexité des algorithmes&nbsp;</i><br>&nbsp;</p><p>Donnez la complexité des algorithmes suivants :<br><strong>Algorithm 2: Algorithme 1</strong><br>&nbsp;</p><blockquote><p>Data :entier $n$</p><p>Result : entier $resultat$</p><p>$resultat←0$;</p><p>for $i$ de $1$ à $n$ do</p><p>$resultat←resultat+i$;</p><p>end for</p><p>return $resultat$;</p></blockquote><p><strong>Algorithm 3: Algorithme 2</strong></p><blockquote><p>Data :entier $n$, entier $m$</p><p>Result : entier $resultat$</p><p>int $i$, $j$;</p><p>$resultat←0$;</p><p>for $i$ de $1$ à $n$&nbsp;do</p><p>for $j$ de $1$ à $m$ do</p><p>$resultat←resultat+i∗j$;</p><p>end for</p><p>end for</p><p>return $resultat$;</p></blockquote><p>&nbsp;</p><p><strong>Algorithm 4: Algorithme 3</strong></p><blockquote><p>Data : entier $n$,</p><p>entier $m$, entier $l$</p><p>Result : entier $resultat$</p><p>int $i$, $j$, $k$;</p><p>$resultat←0$;</p><p>for $i$ de $1$ à $n$ do</p><p>for $j$ de $1$ à $m$ do</p><p>for $k$ de $1$ à $l$ do</p><p>$resultat←resultat+i∗j∗k$;</p><p>end for</p><p>end for</p><p>end for</p><p>return $resultat$;</p></blockquote><p><strong>Algorithm 5: Algorithme 4</strong></p><blockquote><p>Data : entier $n$</p><p>Result : entier $i$</p><p>$i ←0$;</p><p>while $n &gt; 1$ do</p><p>$n←n/2$;</p><p>$i++$;</p><p>end while</p><p>return $i$;</p></blockquote><p>&nbsp;<strong>Exercice 2 : </strong><i>Somme de matrice</i></p><p>Écrire une fonction en langage algorithmique qui prend en paramètre un entier $n$ et un tableau à deux dimensions de taille $n×n$ d’entiers. La fonction calcule la somme des éléments du tableau.&nbsp;</p><p><strong>Exercice 3 :</strong> <i>Multiplication égyptienne</i></p><p>Donnez la complexité de l’algorithme Multiplication égyptienne.</p><p><strong>Algorithm 6: Multiplication égyptienne&nbsp;</strong></p><blockquote><p>Data : entier $a$, entier $b$</p><p>Result : entier $resultat$</p><p>$resultat←0$;</p><p>while $b &gt; 0$ do</p><p>if $bmod2 = 0$ then</p><p>$a←2∗a$;</p><p>$b←b/2$;</p><p>else</p><p>$resultat←resultat+ a$;</p><p>$b←b−1$;</p><p>end if</p><p>end while</p><p>return $resultat$</p></blockquote><p>1 Exécuter l’algorithme avec une instance ( déﬁnissez d’abord l’ensemble des instances).</p><p>2 Donnez la complexité de l’algorithme.<br>&nbsp;</p>",
          "idOnglet": 2,
          "niveau": "2",
          "titre": "element d'algo"
        }
      ]
    },
    {
      "idOnlget": 1,
      "ongletName": "cours",
      "chapters": [
        {
          "id": "AmecTs0vrTCZCB4FxYRn",
          "titre": "recursivité",
          "volumeHoraire": "6",
          "contenu": "<p><strong>1.2 Récursivité&nbsp;</strong><br>&nbsp;</p><p><strong>1.2.1 Introduction</strong></p><p><i><strong>Deﬁnition 1.2.1</strong></i></p><blockquote><p>La récursivité est une démarche qui consiste à faire référence à ce qui fait l’objet de la démarche.</p></blockquote><p><strong>Exemples :</strong></p><p>— Décrire un processus sur des données qui fait appel au même processus sur d’autres données.</p><p>— Montrer une image contenant des images similaires</p><p>— Déﬁnir un concept en invoquant le même concept.</p><p>Le principe de récursivité est utilisé dans la biologie, les arts et la publicité. voilà deux exemples qui illustre ce principe :<br>- Les poupées russes ou matriochkas sont des séries de poupées de tailles décroissantes placées les unes à l’intérieur des autres.</p><figure class=\"image\"><img src=\"https://i.imgur.com/TjbmD0c.png\" alt=\"Poupées russes\"><figcaption>Poupées russes</figcaption></figure><figure class=\"image\"><img src=\"data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==\"></figure><p><br>- Le principe de récursivité est utilisé dans la publicité de la vache qui rit. Dans la boite de la vache qui rit, on aperçoit deux boites de la vache qui rit.</p><figure class=\"image\"><img src=\"https://i.imgur.com/GxSlAhY.png\" alt=\"La vache qui rit\"><figcaption>La vache qui rit</figcaption></figure><figure class=\"image\"><img src=\"data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==\"></figure><p><br><strong>Exemple introductif</strong></p><p>On présente un algorithme qui utilise le principe de récursivité.</p><p><strong>Algorithm 7&nbsp;:&nbsp;</strong><i>Addition</i></p><blockquote><h3>Data : entier $n$</h3><h3>Result : entier $resultat$</h3><h3>if &nbsp;$n&nbsp;&gt; 1$ then</h3><h3>return $n + Addition(n−1)$</h3><h3>else</h3><h3>return $1$;</h3><h3>end if&nbsp;</h3></blockquote><p>Pour $N = 4$, exécutons $Addition(4)$<br>→ $Addition(4) = 4+ Addition(3) = 10$</p><p>→ $Addition(3) = 3+ Addition(2) = 6$</p><p>→ $Addition(2) = 2+ Addition(1) = 3$</p><p>→ $Addition(1) = 1$</p><p><strong>1.2.2 Algorithmes récursifs</strong></p><p><i><strong>Deﬁnition 1.2.2</strong></i></p><blockquote><p>Un algorithme est dit récursif lorsqu’il est déﬁni en fonction de lui-même. Un programme récursif est un programme qui s’appelle lui-même.</p></blockquote><p><strong>Avantages :</strong></p><blockquote><p>1 La récursivité est une notion importante de la programmation.</p><p>2 Elle permet de régler des problèmes complexes d’une manière très rapide.</p><p>3 Un mécanisme naturel qui permet à un sous-programme à faire appel à lui-même.</p><p>4 Outil simpliﬁant, lisible, efﬁcace et souvent sous estimé.</p></blockquote><p><strong>Inconvénients :</strong></p><blockquote><p>Cependant, une méthode avec laquelle il est facile de se perdre et d’avoir des résultats imprévisibles ou erronés.</p></blockquote><p>Modèle générale</p><p>Les algorithmes récursifs respectent le modèle générale suivant :&nbsp;&nbsp;</p><p><strong>Algorithm 8&nbsp;:&nbsp;</strong><i>Modèle général&nbsp;</i></p><blockquote><h3><strong>Data : $Entrées$&nbsp;</strong></h3><h3><strong>Result : $Sorties$</strong></h3><h3>Var : Déclaration des variables locales;</h3><h3><strong>if &nbsp;</strong>Test d’arrêt <strong>then</strong></h3><h3>Instruction du point d’arrêt;</h3><h3><strong>else</strong></h3><h3>Instructions;</h3><h3>$Récursivité(Paramètres changées)$;</h3><h3><strong>end if</strong></h3></blockquote><p><i><strong>Remarque 1.2.3</strong></i></p><blockquote><p>Tout sous-programme récursif doit comporter un test d’arrêt. Le test d’arrêt indique quand est-ce que :</p><p>- on exécute les instructions du point d’arrêt;</p><p>- on arrête les appels récursifs du sous-programme.&nbsp;</p></blockquote><p>Au risque d’entraîner des appels inﬁnis, les paramètres de l’appel récursif doivent changer à chaque appel. Grâce à ces changements de paramètres :</p><p>- l’ordinateur va rencontrer un ensemble de paramètres vériﬁant le test d’arrêt;</p><p>- le sous-programme récursif va atteindre le point terminal.</p><p><strong>Principes de la récursivité :</strong></p><blockquote><p>Les mêmes principes que ceux de la démonstration par récurrence en Mathématiques. On doit avoir :</p><p>- On doit connaitre la solution du premier cas.</p><p>- Un certain nombre de cas simples dont la résolution est connue et qui vont satisfaire le test d’arrêt;</p><p>- Un moyen de ramener un cas compliqué à un cas plus simple.</p></blockquote><p>La récursivité permet d’écrire des algorithmes concis et élégants.</p><p><strong>Dangers de la récursivité :</strong></p><blockquote><p>— La déﬁnition peut être dénuée de sens.</p><p>— Il faut être sûr que l’on retombera toujours sur un cas d’arrêt.</p><p>— Il faut s’assurer que le sous-programme est déﬁni sur tout son domaine d’application.</p></blockquote><p><strong>1.2.3 Problèmes récursifs</strong></p><p><i><strong>Deﬁnition 1.2.4</strong></i></p><blockquote><p>Il existe certains problèmes dont la déﬁnition est récursive.</p><p>— On parle de problèmes récursifs.<br>— Ce genre de problème se programme à l’aide de sous-programmes récursifs.</p></blockquote><p>Les problèmes récursifs peuvent toujours être résolus à l’aide d’algorithmes séquentiels (non-récursif), mais souvent la solution est plus complexe.</p><p>Inversement, certains problèmes itératifs (séquentiel) peuvent être résolus à l’aide de sous-programmes récursifs.&nbsp;&nbsp;</p><p style=\"margin-left:80px;\"><strong>Transformation de boucle en un algorithme récursif.</strong></p><p><strong>Algorithm 9&nbsp;:&nbsp;</strong><i>Calcul de la somme des n premiers naturels : Séquentiel&nbsp;&nbsp;</i></p><blockquote><h3>Data : entier $n$</h3><h3>Result : entier $resultat$</h3><h3>Var : entier $i$;</h3><h3>$resultat←−0$;</h3><h3>for $i ← 1$&nbsp;à $N$ do</h3><h3>$resultat ← resultat+i$</h3><h3>end for</h3><h3>return $resultat$;</h3></blockquote><p>On peut transformer l’algorithme séquentielle d’addition en algorithme récursive.</p><p><strong>Algorithm 10&nbsp;:&nbsp;</strong><i>Calcul de la somme des n premiers naturels : Récursif&nbsp;&nbsp;</i></p><blockquote><h3>Data : entier $n$</h3><h3>Result : entier $resultat$</h3><h3>if &nbsp;$n &gt; 1$ then</h3><h3>return $n+ Addition(n - 1)$</h3><h3>else</h3><h3>return $1$;</h3><h3>end if</h3></blockquote><p>&nbsp;<i><strong>Remarque 1.2.5</strong></i></p><blockquote><p>L’algorithme récursif respecte le modèle générale et un test d’arrêt ($N= 1$). La variable $N$ décroit à chaque nouvel appel, ce qui nous garantit l’arrêt de l’algorithme.</p></blockquote><p>Voila un deuxième exemple, celle de la fonction Factorielle.</p><p><strong>Algorithm 11&nbsp;:&nbsp;</strong><i>Algorithme factorielle : Séquentiel&nbsp;&nbsp;</i></p><blockquote><h3>Data : entier $n$</h3><h3>Result : entier $resultat$</h3><h3>Var : entier $i$;</h3><h3>$resultat ← 1$;</h3><h3>for $i ← 2$ à $N$ do</h3><h3>$resultat ←resultat∗i$;</h3><h3>end for</h3><h3>return $resultat$</h3></blockquote><p>&nbsp;</p><p><strong>Algorithm 12&nbsp;:&nbsp;</strong><i>Algorithme factorielle : Récursif&nbsp;</i></p><blockquote><h3>Data : entier $n$</h3><h3>Result : entier $resultat$</h3><h3>if &nbsp;$N &gt; 1$ then</h3><h3>return $N * Factorielle(N - 1)$;</h3><h3>else</h3><h3>return $1$;</h3><h3>end if</h3></blockquote><p>Certains problèmes sont de nature récursive comme la suite de Fibonacci.</p><p>Suite de Fibonacci</p><p>$$U_n = \\text\"{\" ^{U_0 = U_1 = 1 } _{U_n = U_{n−1} − U_{n−2} n≥2}&nbsp;$$</p><p style=\"margin-left:40px;\"><strong>Algorithme itératif</strong></p><p><strong>Algorithm 13&nbsp;:&nbsp;</strong><i>&nbsp;Suite de Fibonacci : Séquentiel&nbsp;</i></p><blockquote><h3>Data : entier $n$</h3><h3>Result : entier $U_2$</h3><h3>Var : $U_0, U_1, U_2, i $ : entier;</h3><h3>$U_0 ← 1$;</h3><h3>$U_1 ← 1$;</h3><h3>$U_2&nbsp;← 1$;</h3><h3>for $i ← 2$ à $N$ do</h3><h3>$U_i ← U_{i−1} + U_{i−2}$;</h3><h3>$U_{i−2} ← U_{i−1}$;</h3><h3>$U_{i−1} ← U_i $;</h3><h3>end for</h3><h3>return $U_i$</h3></blockquote><p><strong>Algorithm 14&nbsp;:&nbsp;</strong><i>&nbsp;Suite de Fibonacci : Récursif</i></p><blockquote><h3>Data : entier $n$</h3><h3>Result : entier $resultat$</h3><h3>if &nbsp;$N ≥1$ then</h3><h3>return $1;</h3><h3>else</h3><h3>return $Fib(N−1) + Fib(N−2)$;</h3><h3>end if</h3></blockquote><p><i><strong>Remarque 1.2.6</strong></i></p><blockquote><p>L’implémentation de la suite Fibonacci avec un algorithme récursif est plus simple.</p></blockquote><p><i><strong>Deﬁnition 1.2.7</strong></i> <i>Récursivité terminale :</i></p><blockquote><p>On dit qu’un fonction est récursive terminale, si tout appel récursif est de la forme return f(...)</p></blockquote><p><i><strong>Remarque 1.2.8</strong></i></p><blockquote><p>Cette forme de récursivité est bénéﬁque pour la gestion de l’espace mémoire de la fonction.&nbsp;</p></blockquote><p>&nbsp;</p><p>&nbsp;</p>",
          "tags": [
            {
              "libelle": "pointeur",
              "id": "TeLVR7CvcaA3oj3TbYzf"
            },
            {
              "id": "B0hdgMJeAL0EMzs6Vgua",
              "libelle": "complexite"
            }
          ],
          "idCours": "56lW22p1RMMd49td9cHD",
          "idOnglet": 1,
          "niveau": "3"
        },
        {
          "id": "IIoQubwvVaK2z1QoXNmK",
          "contenu": "<p><strong>2.2 Pointeur</strong><br>&nbsp;</p><p>2.2.1 Introduction</p><p>La mémoire centrale d’un ordinateur est composée d’un très grand nombre d’octets. Chaque octet est repéré par un numéro appelé adresse de l’octet. Chaque variable dans la mémoire occupe des octets contigus, c’est-à-dire des octets qui se suivent. Par <strong>Exemple :&nbsp;</strong><br>&nbsp;</p><p style=\"margin-left:40px;\">— Un ﬂoat occupe 4 octets qui se suivent.</p><p style=\"margin-left:40px;\">— Un char occupe 2 octets qui se suivent.</p><p><i><strong>Deﬁnition 2.2.1</strong></i></p><blockquote><p>— Une variable est un espace mémoire nommé.</p><p>— Il est donc possible de parler de l’adresse d’une variable.</p><p>— On note #var l’adresse de la variable var.</p><p>— L’adresse d’une variable est de type pointeur.</p><p>— NIL est un pointeur particulier qui représente une adresse inaccessible que l’on utilise pour dire que le pointeur n’a pas de valeur déterminée.</p><p>— Si add est un pointeur, la valeur pointée par add est notée ∗add</p><p>— On distingue un pointeur sur un entier, d’un pointeur sur un caractère, d’un pointeur sur un réel, même si ce sont tous des adresses.</p><p>— Le type dupointeur est nécessaire pour pouvoir accéder à la valeur pointée.</p></blockquote><p>&nbsp;2.2.2 Exemple</p><p>Nous allons présenter un exemple qui illustre l’intérêt d’utiliser les adresses des variables au lieu d’utiliser les variables.</p><p><strong>Exemple : Personne</strong></p><p style=\"margin-left:40px;\">On voudrait déﬁnir avec une structure de donnée un nouveau type Personne comprenant les informations suivantes :</p><p style=\"margin-left:80px;\">— nom de type chaîne de caractères</p><p style=\"margin-left:80px;\">— prénom de type chaîne de caractères</p><p style=\"margin-left:80px;\">— père de type personne</p><p style=\"margin-left:80px;\">— mère de type personne</p><p style=\"margin-left:40px;\">La structure est la suivante :</p><p style=\"margin-left:80px;\">typedef struct {</p><p style=\"margin-left:120px;\">ch15 nom;</p><p style=\"margin-left:120px;\">ch15 prenom;</p><p style=\"margin-left:120px;\">struct Personne père;</p><p style=\"margin-left:120px;\">struct Personne mére; } Personne;</p><p><i><strong>Remarque 2.2.2</strong></i></p><blockquote><p>Cette structure peut poser les problèmes suivants :</p><p>— La structure est récursive (auto-contenue) puisqu’on décrit une personne comme contenant deux variables de type Personne qui contiennent chacune deux variables de type Personne</p><p>— Cette déclaration est incorrecte car le compilateur ne peut déterminer a priori la taille en octets de la structure Personne.</p></blockquote><p>Nous aurons alors des problèmes d’allocation de mémoire pour créer une instance de la structure personne.</p><p>Aﬁn de résoudre ce problème, nous utilisons les adresses pour les attributs père et mère.</p><p style=\"margin-left:40px;\">typedef struct {</p><p style=\"margin-left:80px;\">ch15 nom;</p><p style=\"margin-left:80px;\">ch15 prenom;</p><p style=\"margin-left:80px;\"><strong>struct Personne *père;</strong></p><p style=\"margin-left:80px;\"><strong>struct Personne *mére; </strong>} Personne;</p><p>Maintenant, on peut utiliser correctement la structure de donnée Personne. Chaque fois qu’on initialise une instance , on allouent la mémoire seulement pour adresses des attributs père et mère.</p><p><strong>Exemple</strong></p><p style=\"margin-left:40px;\">Youssef ← new Personne()</p><p style=\"margin-left:40px;\">Mohammed ← new Personne()</p><p style=\"margin-left:40px;\">Aicha ← new Personne()</p><p style=\"margin-left:40px;\">Youssef.prenom ← \"youssef\";</p><p style=\"margin-left:40px;\">Youssef.prenom ← \"Bencheikh\";</p><p style=\"margin-left:40px;\">Youssef→père ← Mohammed;</p><p style=\"margin-left:40px;\">Youssef→mère ← Aicha;<br>&nbsp;</p>",
          "idOnglet": 1,
          "tags": [
            {
              "libelle": "pointeur",
              "id": "TeLVR7CvcaA3oj3TbYzf"
            }
          ],
          "volumeHoraire": "4",
          "niveau": "2",
          "idCours": "56lW22p1RMMd49td9cHD",
          "titre": "pointeur"
        },
        {
          "id": "TnpWHiL2XYUFALYFWjqj",
          "volumeHoraire": "5",
          "contenu": "<p><strong>2.3 Tableaux</strong><br>&nbsp;</p><p><i><strong>Deﬁnition 2.3.1&nbsp;</strong></i><br>&nbsp;</p><blockquote><p>Un tableau est une structure de donnée T qui permet de stocker un certain nombre d’éléments $T[i]$ repérés par un index $i$. Les tableaux vériﬁent généralement les propriétés suivantes :</p><p style=\"margin-left:40px;\">1 Tous les éléments ont le même type de base;</p><p style=\"margin-left:40px;\">2 Le nombre des éléments stockés est ﬁxé;</p><p style=\"margin-left:40px;\">3 L’accès et la modiﬁcation de l’élément numéro i est en temps constant O(1), indépendant de i et du nombre d’éléments dans le tableau.</p></blockquote><p>&nbsp;Les opérations de base pour un tableau sont :</p><p style=\"margin-left:40px;\">— accès au premier élément : $O(1)$&nbsp;</p><p style=\"margin-left:40px;\">— accès à l’élément numéro $i$ : $O(1)$</p><p style=\"margin-left:40px;\">— accès au dernier élément : $O(1)$</p><p style=\"margin-left:40px;\">— insertion d’un élément au début : $O(taille)$</p><p style=\"margin-left:40px;\">— insertion d’un élément en position $i$ : $O(taille-i) = O(taille)$</p><p style=\"margin-left:40px;\">— insertion d’un élément à la ﬁn : $O(1)$</p><p>L’opération de suppression doit permettre l’élimination de l’élément du tableau mais aussi la réorganisation du tableau.</p><p>La suppression d’un élément passe par les étapes suivantes :</p><p style=\"margin-left:40px;\">— recopier les éléments temporairement;</p><p style=\"margin-left:40px;\">— ré-allouer de la mémoire pour le tableau;</p><p style=\"margin-left:40px;\">— remplir le tableau dans l’ordre sauf l’élément supprimé.</p><p><i><strong>Remarque 2.3.2</strong></i></p><blockquote><p>1 L’algorithme de la suppression d’un élément peut être optimisé de la façon suivante :</p><p><strong>Algorithm 22&nbsp;:&nbsp;</strong><i>La suppression d’un élément&nbsp;</i></p></blockquote><blockquote><h3>Data : tableau $T$, entier $n$, entier $j$</h3><h3>Result : tableau $T$</h3><h3>Var : $i$ entier;</h3><h3>for $i ← j$ à $n−2$ do</h3><h3>$T[i] ← T[i+1]$;</h3><h3>end for</h3><h3>return $T$;</h3></blockquote><blockquote><p>2 La création d’un tableau nécessite :</p><p style=\"margin-left:40px;\">a connaîtresa taille;</p><p style=\"margin-left:40px;\">b placer ses éléments de façon contiguë en mémoire.&nbsp;</p></blockquote><p>&nbsp;La suppression est une opération qui consomme trop de ressources (la complexité est la taille du tableau ).</p><p>La structure du tableau pose un autre problème celui de taille Maximum : on essaye d’insérer un élément dans un tableau où tous les cases sont remplis, le programme s’arrête avec une erreur : Dépassement de la taille.</p>",
          "idOnglet": 1,
          "idCours": "56lW22p1RMMd49td9cHD",
          "tags": [
            {
              "libelle": "pointeur",
              "id": "TeLVR7CvcaA3oj3TbYzf"
            },
            {
              "libelle": "complexite",
              "id": "B0hdgMJeAL0EMzs6Vgua"
            }
          ],
          "titre": "tableau",
          "niveau": "2"
        },
        {
          "id": "mdG7DerT5eZG0GtMGvUp",
          "contenu": "<p><i><strong>Deﬁnition 2.1.1&nbsp;</strong></i><br>&nbsp;</p><blockquote><p>Une structure de données est un moyen de stocker et organiser des données pour faciliter l’accès aux données et leur modiﬁcation.</p></blockquote><p><i><strong>Remarque 2.1.2</strong></i></p><blockquote><p>Chaque structure de données a ses avantages et ses inconvénients.</p><p>On choisit notre structure de données suivant les opérations effectuées sur nos données ( Recherche, suppression, ajout ...)</p></blockquote>",
          "idOnglet": 1,
          "tags": [
            {
              "libelle": "file",
              "id": "CyxU2MpGRo7XZAuUsMhG"
            },
            {
              "id": "vDaTMVmYliI15e4fkVWK",
              "libelle": "liste chainé"
            },
            {
              "libelle": "pile",
              "id": "gYkj13NGaBdrl8TNJg31"
            },
            {
              "libelle": "pointeur",
              "id": "TeLVR7CvcaA3oj3TbYzf"
            }
          ],
          "titre": "structure de données",
          "volumeHoraire": "8",
          "niveau": "4",
          "idCours": "56lW22p1RMMd49td9cHD"
        },
        {
          "id": "s7ofCnmQ92RBEQEOnGNR",
          "volumeHoraire": "8",
          "idCours": "56lW22p1RMMd49td9cHD",
          "idOnglet": 1,
          "niveau": "3",
          "tags": [
            {
              "id": "3K9gsODPePO5B2jjrl3P",
              "libelle": "tri"
            },
            {
              "id": "B0hdgMJeAL0EMzs6Vgua",
              "libelle": "complexite"
            },
            {
              "id": "TeLVR7CvcaA3oj3TbYzf",
              "libelle": "pointeur"
            }
          ],
          "contenu": "<p><strong>1.3 Algorithmes de tri</strong><br>&nbsp;</p><p><i><u>1.3.1 Tri par sélection</u></i></p><p><strong>Principe du tri par sélection&nbsp;</strong><br>&nbsp;</p><p>Soit un tableau T de taille $n$. Le principe du tri par sélection est le suivant :</p><p>1 On sélectionne le maximum (le plus grand) de tous les éléments</p><p>2 on le place en dernière position $n-1$ par un échange</p><p>3 Il ne reste plus qu’à trier les $n-1$ premiers éléments, pour lesquels on itère le procédé.</p><p><br><strong>Exemple Tri par sélection :</strong>&nbsp;</p><p>Soit le tableau suivant:</p><figure class=\"table\"><table><tbody><tr><td>6</td><td>3</td><td>7</td><td>2</td><td>3</td><td>5</td></tr></tbody></table></figure><p>&nbsp;Le maximum du tableau est 7.Plaçons le 7 en dernière position par un échange&nbsp;</p><figure class=\"table\"><table><tbody><tr><td>6</td><td>3</td><td>5</td><td>2</td><td>3</td><td>7</td></tr></tbody></table></figure><p>Le 7 est à sa position déﬁnitive; il ne reste plus qu’à trier les cinq premiers éléments. Le maximum de ces cinq éléments est 6. Plaçons le à la ﬁn par un échange :</p><figure class=\"table\"><table><tbody><tr><td>3</td><td>3</td><td>5</td><td>2</td><td>6</td><td>7</td></tr></tbody></table></figure><p>Le maximum parmi les nombres restant à trier est 5. Plaçons le en dernière position par un échange :</p><figure class=\"table\"><table><tbody><tr><td>3</td><td>3</td><td>2</td><td>5</td><td>6</td><td>7</td></tr></tbody></table></figure><p>Enﬁn le maximum parmi les nombres à trier est 3. On le place en dernier et le tableau est trié. :</p><figure class=\"table\"><table><tbody><tr><td>2</td><td>3</td><td>3</td><td>5</td><td>6</td><td>7</td></tr></tbody></table></figure><p><strong>Algorithme tri par sélection</strong></p><p><strong>&nbsp;Algorithm 18 :&nbsp;</strong><i>Algorithme de tri par sélection&nbsp;</i></p><blockquote><h3>Data : tableau $t$, entier $n$</h3><h3>Var : $i$, &nbsp;$j$, $i_{max}$ : entier, $z$ : réel</h3><h3>for $i ←n−1$ à $1$ do</h3><h3>\\∗recherche de l’indice du maximum :∗\\;</h3><h3>$i_{max} ←0$;</h3><h3>for $j←0$ à $i$ do</h3><h3>if ($T(i_{max}) &lt; T(j)$) then</h3><h3>$i_{max} ← j$;</h3><h3>end if</h3><h3>end for</h3><h3>\\∗échange :∗\\;</h3><h3>$z ← T(i_{max})$;</h3><h3>$T(i_{max}) ← T(i)$;</h3><h3>$T(i) ←z$;</h3><h3>end for</h3></blockquote><p><strong>Complexité</strong></p><blockquote><p>- Coût des échanges. Le tri par sélection sur $n$ nombres fait $n - 1$ échanges, ce qui fait $3(n - 1)$ affectations</p><p>- Coût des recherches de maximum :</p><p style=\"margin-left:80px;\">- On recherche le maximum parmi $n$ éléments : au plus $4(n - 1)$ opérations. (c’est le nombre des itérations de la boucle sur $i$ pour $k$ ﬁxé égal à $n-1$)</p><p style=\"margin-left:80px;\">1 On recherche ensuite le maximum parmi $n$</p><p style=\"margin-left:80px;\">2 $1$ élément : au plus $4(n-2)$ tests. (c’est le nombre des itérations de la boucle sur $i$ pour $k$ ﬁxé égal à $n-2$)</p><p style=\"margin-left:80px;\">3 On recherche ensuite le maximum parmi $n -2$ éléments : $4(n-3)$ tests.</p><p style=\"margin-left:80px;\">4 ···</p></blockquote><p>Le nombre total de tests est de :&nbsp;$$ 4(1+2+3+···+ (n−2) + (n−3)) = {4(n−2)(n−3)}/{2} $$&nbsp;</p><p>La complexité est : $$ 3(n−1) + {4(n−2)(n−3)}/{2} $$&nbsp;</p><p>On dit que la méthode est quadratique, ou encore qu’elle est une méthode en $O(n^2)$. La partie de degré $1$ en $n$ est négligeable devant la partie en $n^2$ quand $n$ devient grand.</p><p><i><u>1.3.2 Tri par Insertion</u></i></p><p><strong>Principe tri par insertion</strong></p><p>Le principe du tri par insertion est le suivant :</p><blockquote><p>1/ On trie d’abord les deux premiers éléments</p><p>2/ On insère le troisième à sa place pour faire une liste triée de 3 éléments</p><p>3/ On insère le quatrième élément dans la liste triée</p><p>4/ La liste triée grossit jusqu’à contenir les n éléments.</p></blockquote><p><strong>Exemple tri par insertion</strong></p><p style=\"margin-left:40px;\">Soit le tableau suivant :</p><figure class=\"table\"><table><tbody><tr><td>6</td><td>3</td><td>4</td><td>2</td><td>3</td><td>5</td></tr></tbody></table></figure><p style=\"margin-left:40px;\">&nbsp;En triant les deux premiers éléments on obtient :</p><figure class=\"table\"><table><tbody><tr><td>3</td><td>6</td><td>4</td><td>2</td><td>3</td><td>5</td></tr></tbody></table></figure><p style=\"margin-left:40px;\">En insérant le troisième élément à sa place dans la liste triée :</p><figure class=\"table\"><table><tbody><tr><td>3</td><td>4</td><td>6</td><td>2</td><td>3</td><td>5</td></tr></tbody></table></figure><p style=\"margin-left:40px;\">En insérant le quatrième élément à sa place dans la liste triée :</p><figure class=\"table\"><table><tbody><tr><td>2</td><td>3</td><td>4</td><td>6</td><td>3</td><td>5</td></tr></tbody></table></figure><p style=\"margin-left:40px;\">En insérant le cinquième élément à sa place dans la liste triée :&nbsp;</p><figure class=\"table\"><table><tbody><tr><td>2</td><td>3</td><td>3</td><td>4</td><td>6</td><td>5</td></tr></tbody></table></figure><p style=\"margin-left:40px;\">En insérant le dernier élément à sa place dans la liste triée :&nbsp;</p><figure class=\"table\"><table><tbody><tr><td>2</td><td>3</td><td>3</td><td>4</td><td>5</td><td>6</td></tr></tbody></table></figure><p><strong>Algorithme tri par insertion</strong></p><p><strong>&nbsp;Algorithm 19&nbsp;:&nbsp;</strong><i>Algorithme de tri par insertion&nbsp;</i></p><blockquote><h3>Data : tableau $t$, entier $n$</h3><h3>Var : $i$, &nbsp;$j$ : entier, $z$ : réel;</h3><h3>for $i ← 1$ à $n−1$ do</h3><h3>$j ← i−1$</h3><h3>$z← T[i]$</h3><h3>while $ j &gt; 0$ et $z &lt; T[j]$ do</h3><h3>$j ← j−1$</h3><h3>end while</h3><h3>$echange(T,i,j)$;</h3><h3>end for</h3></blockquote><p><strong>Complexité</strong></p><blockquote><p>- Pour chaque indice $i$ varie de $1$ à $n - 1$</p><p>- L’indice $j$ prend au plus $i$ valeurs.</p><p>- Lenombred’opérationsestdoncauplusde: $3(n−1) +4(1+2+···+ (n−2) +n−1)$</p><p>- Le nombre d’opérations est:&nbsp;: $ 3(n−1) + {4(n−1)n}/{2} $</p></blockquote><p><i><u>1.3.3 Tri par fusion</u></i></p><p><strong>Principe tri par fusion</strong></p><p>Le paradigme diviser-pour-régner implique trois étapes à chaque niveau de la récursivité :</p><blockquote><p>1 Diviser : le problème en un certain nombre de sous-problèmes.</p><p>2 Régner : sur les sous-problèmes en les résolvant de manière récursive. Si la taille d’un sous-problème est sufﬁsamment réduite, on peut toute fois le résoudre directement.</p><p>3 Combiner: les solutions dessous-problèmes pour produire la solution du problème original.</p></blockquote><p>L’algorithme du tri par fusion suit ﬁdèlement la méthodologie diviser-pourrégner.</p><p>Intuitivement, il agit de la manière suivante :</p><blockquote><p>1 Diviser : Diviser la suite de n éléments à trier en deux sous-suites de $n/2$ éléments chacune.</p><p>2 Régner : Trier les deux sous-suites de manière récursive en utilisant le tri par fusion.</p><p>3 Combiner : Fusionner les deux sous-suites triées pour produire la réponse triée.</p></blockquote><p>L’algorithme de tri par fusion est un algorithme récursif : chaque demi tableau est divisée pour être trié(on applique la même procédure sur chaque moitié du tableau).</p><p>La récursivité s’arrête quand la séquence à trier a une longueur 1, au quel cas il n’y a plus rien à faire puisqu’une suite de longueur 1 est déjà triée. Nous aurons besoin d’une fonction qui fusionne deux tableaux triés.</p><p><br><strong>Exemple tri par fusion:&nbsp;</strong></p><figure class=\"image\"><img src=\"https://i.imgur.com/aW15Od9.png\" alt=\"\"></figure><p style=\"text-align:center;\">​</p><figure class=\"image\"><img src=\"data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==\"></figure><p>Le tableau est divisé en cellules. On fusionne ensuite chaque deux éléments, ce qui nous donne des tableaux de deux cellules. On recommence l’opération defusion.La fusion de chaque deux demi-tableaux conduit à trier le tableau. A la ﬁn, on obtient un tableau trié.</p><p><strong>Algorithme tri par fusion</strong></p><p>Nous présentons d’abord la&nbsp;procédure de Fusion qui permet de fusionner deux tableaux triés dans un tableau trié.</p><p>La procédure de la fusion prend en argument deux tableaux T1 et T2 et renvoie T la fusion des deux tableaux trié.</p><p><strong>&nbsp;Algorithm 20&nbsp;:&nbsp;</strong><i>Algorithme Fusion&nbsp;</i></p><blockquote><h3>Data : tableau $T1$, tableau $T2$, entier $n1$, entier $n2$</h3><h3>Result : tableau $T$</h3><h3>Var : $i$, $i1$, $i2$ : entier;</h3><h3>$i ← 0$;</h3><h3>$i1 ← 0$;</h3><h3>$i2 ← 0$</h3><h3>while $i1 &lt; n1$ et $i2 &lt; n2$ do</h3><h3>if &nbsp;$T1[i1] &lt; T2[i2]$ then</h3><h3>$T[i] ← T1[i1]$;</h3><h3>$i1++$;</h3><h3>$i++$</h3><h3>else</h3><h3>$T[i] ← T2[i2]$;</h3><h3>$i2++$;</h3><h3>$i++$</h3><h3>end if</h3><h3>end while</h3><h3>if &nbsp;$i1 &lt; n1$ then</h3><h3>while $i1 &lt; n1$ do</h3><h3>$T[i] ← T1[i1]$;</h3><h3>$i1++$;</h3><h3>$i++$</h3><h3>end while</h3><h3>else</h3><h3>while $i2 &lt; n2$ do</h3><h3>$T[i] ← T2[i2]$;</h3><h3>$i2++$;</h3><h3>$i++$</h3><h3>end while</h3><h3>end if</h3></blockquote><p><strong>Le procédure de tri par fusion est le suivant :</strong></p><p><strong>Algorithm 21&nbsp;:&nbsp;</strong><i>Algorithme tri par fusion&nbsp;</i></p><blockquote><h3>Data : tableau $T1$, tableau $T2$, entier $n1$, entier $n2$</h3><h3>Result : tableau $T$</h3><h3>Var : $mid$ : entier, $Temp$ :réel par référence;</h3><h3>if &nbsp;$min&nbsp;&lt; max$ then</h3><h3>$mid ← {min+max} / {2}$ ;</h3><h3>$TriFusion(T, min, mid)$;</h3><h3>$TriFusion(T, mid, max)$;</h3><h3>$Fusion(T[min,mid],T[mid+1, max], Temp]$;</h3><h3>Copie de Temp dans $T[min,max]$;</h3><h3>end if</h3></blockquote><p><strong>Complexité</strong></p><blockquote><p>— Soit $T(n)$ la complexité de la fonction TriFusion pour un tableau de taille $n$</p><p>— Nous aurons la relation suivante : $T(n) = \\text\"{\"&nbsp; ^{O(1) &nbsp;\\text\" si \" n = 1 } &nbsp;_{2T(n /2) + O(n) \\text \" si \" n &gt; 1} $</p><p>— La complexité est d’ordre $nlog(n)$.</p></blockquote>",
          "titre": "algoritme de  tri"
        },
        {
          "id": "uP6Ap9gS8ZtVJM2V1Rp9",
          "niveau": "2",
          "idCours": "56lW22p1RMMd49td9cHD",
          "titre": "element d'algorithme",
          "contenu": "<p><strong>1.1 Complexité Algorithmique</strong><br>&nbsp;</p><p><br><strong>Historique:</strong>&nbsp;Les scientiﬁques proposent un moyens ﬁable pour mesurer l’efﬁcacité des algorithmes. Il nous faut une démarche théorique indépendante de:<br>&nbsp;</p><blockquote><p>— processeur utilisé;</p><p>— les temps d’accès à la mémoire vive et de masse;</p><p>— le langage de programmation;</p><p>— le compilateur utilisé;</p><p>— etc.</p></blockquote><p><br>1.1.1 Notations et déﬁnitions</p><p>La théorie de la complexité algorithmique s’intéresse à l’estimation de l’efﬁcacité des algorithmes. Elle s’attache à connaître la difﬁculté d’une réponse par algorithme à un problème posé de façon mathématique.</p><p><strong>Question de base :</strong></p><blockquote><p>Entre différents algorithmes réalisant une même tâche, quel est le plus optimal (rapide), et dans quelles conditions?</p></blockquote><p><strong>Principes :</strong></p><blockquote><p>La théorie de la complexité vise à savoir si la réponse à un problème peut être donnée très efﬁcacement ou au contraire être in-atteignable en pratique ( Certains problèmes peuvent prendre des jours ou des mois de calculs par n’importe quel machine).</p><p>Elle se fonde sur une estimation théorique des temps de calcul et des besoins en mémoire informatiques.</p></blockquote><p><i><strong>Deﬁnition 1.1.1</strong></i></p><blockquote><p><strong>&nbsp;</strong>La complexité d’un algorithme est la mesure du nombre d’opérations fondamentales qu’ileffectuesurunjeudedonnées.Lacomplexitéestexpriméecommeunefonctionde la taille du jeu de données( entrée). La complexité algorithmique est un moyen d’évaluation du coût d’un algorithme. Cettecomplexitémesurelenombred’opérationsélémentairesetlecoûtmémoire.(Addition, soustraction, multiplication, division, affectation, fonctions élémentaires : racine...) Cela permet de connaître le type de croissance en fonction de la taille des données.</p></blockquote><p><strong>&nbsp;Algorithm 1 :&nbsp;</strong><i>Complexité de calcul de factorielle d’un tableau</i></p><blockquote><h3>Data : tableau $Tab$, entier $n$</h3><h3>Result : reel $Fact$</h3><h3>$Fact← Tab[0]$;</h3><h3>if $n &gt; 1$ then</h3><h3>for $i ← 2$ à $n$ do</h3><h3>$Fact← Fact∗Tab[i]$;</h3><h3>end for</h3><h3>end if</h3><h3>return $Fact$;</h3></blockquote><p><i><strong>Remarque 1.1.2</strong></i></p><blockquote><p>Le nombre d’opérations est :</p><p>— $Fact← Tab[0]$ : une affectation</p><p>— Si ( $n &gt; 1$) :une comparaison</p><p>— Pour $i ← 2$ à $n$ : $n-1$ comparaison et affectation</p><p>— $Fact ← Fact∗Tab[i]$: $n-1$ multiplication et affectation</p><p>Nous avons $4n−2$ opération. Le temps de calcul augmente en fonction du taille du tableau d’une façon polynomiale.</p></blockquote><p>&nbsp;1.1.2 Formalisation Mathématique :</p><p>On considère un problème algorithmique où :</p><p>— $D_n$ est un jeux de donnée : une instance.</p><p>— $n$ est la taille des données d’entrée $D_n$.</p><p>— $T(D_n)$ est la complexité d’algorithme pour le jeux de donnée $D_n$ La complexité d’un algorithme peut se calculer de différentes méthodes.</p><p><i><strong>Deﬁnition 1.1.3</strong></i></p><blockquote><p><strong>Complexité au meilleur :</strong></p><p>$T_{min}(n) = min_{d∈D_n} T(d)$ C’est le plus petit nombre d’opération qu’aura à exécuter l’algorithme sur un jeu de données de taille $n$&nbsp;</p><p><strong>Complexité au pire :</strong></p><p>$T_{max}(n) = max_{d∈D_n} T(d) $ C’est le plus grand nombre d’opération qu’aura à exécuter l’algorithme sur un jeu de données de taille $n$&nbsp;</p><p><strong>Complexité au moyenne :</strong></p><p>$T_{moy} (n) = ∑↙{d∈D_n} {T(d)}/{|D_n|} $ C’est la moyenne de complexité de l’algorithme sur des jeux de données de taille $n$.<br>&nbsp;</p></blockquote><p>&nbsp;</p><p><i><strong>Remarque 1.1.4</strong></i></p><p>Nous nous intéressons en réalité qu’au complexité au pire.<br>On étudie systématiquement la complexité asymptotique, notée grâce au notions landau :</p><blockquote><p><strong>— Idée 1 :</strong> Évaluer l’algorithme sur des données de grandes taille :</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;- Exemple: Lorsque $n$ est grand, $n^3 +3n^2$&nbsp;est asymptotiquement égale à $n^3$.</p><p><strong>— Idée 2 :</strong> On élimine les constantes multiplicateurs, par exemple $3n^3$ est équivalent à $n^3$.</p><p><strong>— Idée3:&nbsp;</strong>Un algorithme est en $O(n^a)$ est meilleur qu’un algorithme en $O(n^b)$ si $a &lt; b$.&nbsp;&nbsp;</p></blockquote><p><strong>Exemple :</strong></p><p>Nous utilisons la méthode suivante pour calculer la complexité de notre algorithme :</p><p>1 Attribution d’un coût à chaque opération</p><p>2 Comptons le nombre d’exécution de chaque instruction</p><p>3 Pourchaquevaleur $j∈ [2,n]$, notons $t_j$ le nombre d’exécution de la boucle tant que pour la valeur $j$.<br><br>&nbsp;</p><figure class=\"table\"><table><thead><tr><th>Algorithme&nbsp;</th><th>Coût&nbsp;</th><th>Nombre d’exécution</th></tr></thead><tbody><tr><td>Pour $j←2 \\text\" à \"n$ faire</td><td>$c_1$&nbsp;</td><td>$n−1$&nbsp;</td></tr><tr><td>$Clef← A(j)$</td><td>$c_2$</td><td>$n−1$</td></tr><tr><td>$i ← j−1 $faire</td><td>$c_3$&nbsp;</td><td>$n−1$</td></tr><tr><td>Tant que $i &gt; 0$ et $A(i) &gt; Clef$ faire</td><td>$c_4$</td><td>$∑↙{j=2}↖n t_j$&nbsp;&nbsp;</td></tr><tr><td>$A(i) ← A(i−1)$</td><td>$c_5$&nbsp;</td><td>$∑↙{j=2}↖n t_j - 1$&nbsp;&nbsp;</td></tr><tr><td>$i ←i−1 $</td><td>$c_6$</td><td>$∑↙{j=2}↖n t_j - 1$&nbsp;&nbsp;</td></tr><tr><td>Fin tant que&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td>$A(i+1) ←clef$&nbsp;</td><td>$c_7$</td><td>$n - 1$</td></tr><tr><td>Fin Pour</td><td>&nbsp;</td><td>&nbsp;</td></tr></tbody></table></figure><p><strong>Le temps totale d’exécution de l’algorithme est :</strong></p><p>$T(n) = &nbsp;c_1n + c_2(n-1) + c_3(n-1) + c_4∑↙{j=2}↖n t_j + c_5∑↙{j=2}↖n t_j - 1 + c_6∑↙{j=2}↖n t_j - 1 + c_7(n-1)$</p><p><strong>Complexité au meilleur :</strong></p><p>Le cas le plus favorable pour l’algorithme correspond au $t_j = 1$ pour tout $j∈ [2,n]$</p><p>$T(n) = (c_1 +c_2 +c_4 +c_7)n + (c_2 +c_3 +c_4 +c_7)$</p><p>1 $T(n)$ peut s’écrire sous la forme $an+b$</p><p>2 On dit que l’algorithme au meilleur de cas est d’ordre $O(n)$</p><p>3 On dit aussi que l’algorithme est meilleur de complexité polynomiale Le temps totale d’exécution de l’algorithme est<br>$T(n) = c_1n + c_2(n−1) + c_3(n−1) + c_4∑↙{j=2}↖n t_j + c_5∑↙{j=2}↖n t_j - 1&nbsp;+ c_6∑↙{j=2}↖n t_j - 1 + c_7(n−1)$</p><p><strong>Complexité au pire:</strong></p><p>Le cas le moins favorable pour l’algorithme correspond au $t_j = j$ pour tout $j∈ [2,n]$</p><p>Dans ce cas nous avons : $∑↙{j=2}↖n &nbsp;j = {(n+2)(n-1)}/2$ et $∑↙{j=2}↖n &nbsp;(j-1) = {n(n-1)}/2$<br>$T(n) = (c_4 + c_5 + c_6)n^2/2 +&nbsp;(c_1 + c_2 + c_3 + c_4/2 +&nbsp;c_5/2 + c_6/+c_7)n − (c_2 + c_3 + c_4 + c_7)$<br>1 $T(n)$ peut s’écrire sous la forme $an^2 + bn + c$</p><p>2 On dit que l’algorithme est au pire d’ordre $O(n^2)$</p><p><i><strong>Remarque 1.1.5</strong></i></p><blockquote><p>Ce qui nous intéresse vraiment, c’est l’ordre de grandeur du temps d’exécution Seuls les termes dominants de la formule de la complexité nous importent.</p></blockquote><figure class=\"table\"><table><thead><tr><th>Notation</th><th>Classe de complexité</th></tr></thead><tbody><tr><td>$O(1)$&nbsp;</td><td>Complexité constante: indépendante de la taille de la donnée.</td></tr><tr><td>$O(log(n))&nbsp;$</td><td>Complexité logarithmique&nbsp;</td></tr><tr><td>$O(n)$</td><td>Complexité linéaire</td></tr><tr><td>$O(nlog(n))$</td><td>Complexité quasi-linéaire&nbsp;</td></tr><tr><td>$O(n^2)$</td><td>Complexité quadratique&nbsp;</td></tr><tr><td>$O(n^3$</td><td>Complexité cubique&nbsp;</td></tr><tr><td>$O(n^p)$</td><td>Complexité polynomiale&nbsp;</td></tr><tr><td>$O(n^{log(n)})$</td><td>Complexité quasi-polynomiale&nbsp;</td></tr><tr><td>$O(2^n)$</td><td>Complexité exponentielle</td></tr><tr><td>$O(n!)$</td><td>Complexité factorielle</td></tr></tbody></table></figure><p><i><strong>&nbsp;Remarque 1.1.6</strong></i></p><blockquote><p>On considère souvent qu’un algorithme de complexité exponentielle ou factorielle est un algorithme non réalisable.</p></blockquote>",
          "idOnglet": 1,
          "tags": [
            {
              "libelle": "complexite",
              "id": "B0hdgMJeAL0EMzs6Vgua"
            }
          ],
          "volumeHoraire": "4"
        },
        {
          "id": "yhtr3u45OtU9m8TGroTA",
          "volumeHoraire": "5",
          "titre": "liste chainé",
          "idCours": "56lW22p1RMMd49td9cHD",
          "niveau": "4",
          "tags": [
            {
              "libelle": "liste chainé",
              "id": "vDaTMVmYliI15e4fkVWK"
            },
            {
              "id": "TeLVR7CvcaA3oj3TbYzf",
              "libelle": "pointeur"
            }
          ],
          "contenu": "<p><strong>2.4 Listes chainées&nbsp;</strong><br>&nbsp;</p><p>2.4.1 Introduction<br>&nbsp;</p><p>La gestion de notion d’ensemble est fait souvent en utilisant des tableaux. On peut, par exemple, représenter l’ensemble des entiers $A=\\text\"{\"4,17,21,13,5\\text\"}\"$ avec un tableau à cinq cases.</p><figure class=\"image\"><img src=\"https://i.imgur.com/9irmnzd.png\" alt=\"\"></figure><p style=\"text-align:center;\">​</p><figure class=\"image\"><img src=\"data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==\"></figure><p>On peut ranger nos éléments d’une autre façon.</p><p style=\"margin-left:40px;\">1-On sépare les cases :</p><figure class=\"image\"><img src=\"https://i.imgur.com/98yX2rN.png\" alt=\"\"></figure><p style=\"text-align:center;\">​</p><figure class=\"image\"><img src=\"data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==\"></figure><p style=\"margin-left:40px;\">2-Chaque élément doit connaitre l’élément suivant, on ajoute à chaque élément une case qui stock l’adresse de l’élément suivants :<br><br>&nbsp;</p><figure class=\"image\"><img src=\"https://i.imgur.com/D1sfbk2.png\" alt=\"\"></figure><p style=\"text-align:center;\">​</p><figure class=\"image\"><img src=\"data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==\"></figure><p style=\"margin-left:40px;\">3- Pour le dernier élément, on ajoute une adresse nul pour le dernier élément.</p><figure class=\"image\"><img src=\"https://i.imgur.com/9TkFYqO.png\" alt=\"\"></figure><p style=\"text-align:center;\">​</p><figure class=\"image\"><img src=\"data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==\"></figure><p><i><strong>Deﬁnition 2.4.1</strong></i></p><blockquote><p>— Une liste chaînée est une structure de données dans laquelle les éléments sont rangés linéairement.</p><p>— Cette linéarité est purement virtuelle.</p><p>— A la différence du tableau, les éléments n’ont aucune raison d’être contigus ni ordonnés en mémoire.</p></blockquote><p>2.4.2 Déﬁnition et terminologie</p><p>Pour déﬁnir une liste chaînée il faut d’abord déﬁnir un nouveau type de variable : la cellule qui compose la chaîne.</p><p style=\"margin-left:40px;\">struct {</p><p style=\"margin-left:80px;\">int valeur</p><p style=\"margin-left:80px;\">maillon * suivant</p><p style=\"margin-left:80px;\">} maillon</p><p>La structure contient la valeur de la cellule ( ça peut contenir autre type qu’un entier) et le pointeur qui indique l’emplacement de l’élément suivant dans la chaîne.</p><p><i><strong>Deﬁnition 2.4.2</strong></i></p><blockquote><p>Une liste simplement chaînée est un ensemble des maillons tel que chaque maillon connais le maillon suivant. Il sufﬁt de connaitre le premier maillon pour accéder à chaque maillon.</p><p>Une liste simplement chaînée est un pointeur sur le premier maillon.</p></blockquote><p><strong>Exemple :&nbsp;</strong><i>Création d’une liste de quatre maillons</i></p><p>Var : $cell1$, $cell2$, $cell3$, $cell4$ : maillon</p><p>Var : liste *maillon $cell1$.</p><p>$valeur ← 17$</p><p>$cell1.suivant ← &amp; cell2$</p><p>$cell2.valeur ← 21$</p><p>$cell2.suivant ← &amp; cell3$</p><p>$cell3.valeur ← 13$</p><p>$cell3.suivant ← &amp; cell4$</p><p>$cell4.valeur ← 5$</p><p>$cell4.suivant ← NUL$</p><p>$liste ← &amp;cell1$ &nbsp;</p><p>Une façon simple de se représenter une liste, consiste à dire qu’une liste L est :</p><p style=\"margin-left:40px;\">— soit vide;</p><p style=\"margin-left:40px;\">— soit constituée de :</p><p style=\"margin-left:80px;\">1 une tête $t$ qui est la valeur du premier élément de la liste;</p><p style=\"margin-left:80px;\">2 une queue $q$ qui est le reste de la liste.</p><p>Accès au champs d’une liste chaînée</p><p style=\"margin-left:40px;\">1 La valeur du premier maillon de la liste : list.valeur</p><p style=\"margin-left:40px;\">2 Le deuxième élément de la liste chaînée: maillon deuxième = list.suivant;</p><p style=\"margin-left:40px;\">3 La valeur du deuxième maillon deuxième.valeur</p><p><i><strong>Remarque 2.4.3</strong></i></p><blockquote><p>L’accès au $i^{éme}$ maillon se fait en parcourant les maillons de $1$ à $i−1$.</p></blockquote><p>2.4.3 Algorithmes Liste chaînée</p><p>La manipulation d’une liste peut se faire grâce aux opérations suivantes :</p><p style=\"margin-left:40px;\">1 Liste $Vide()$ : Liste (Création d’une liste vide)</p><p style=\"margin-left:40px;\">2 $Cons(t:entier,q:Liste)$ : Liste(Création d’une liste dont le premier maillon sa valeur est $t$, et son pointeur pointe sur la liste $q$)</p><p style=\"margin-left:40px;\">3 $Tete(list : Liste)$ : Entier (renvoie la valeur du premier maillon)</p><p style=\"margin-left:40px;\">4 $Queue(list : Liste)$ : Liste (renvoie la liste sans le premier maillon)</p><p>Nous présentons quelques algorithmes utilisés pour manipuler les listes chaînées.</p><p>Cet algorithme teste si une liste est vide.</p><p><i><strong>Remarque 2.4.4</strong></i></p><blockquote><p>La complexité de l’algorithme est $O(1)$.</p></blockquote><p>Cet algorithme calcule la longueur d’une liste.</p><p><strong>Algorithm 23&nbsp;:&nbsp;</strong><i>Algorithme teste si une liste est vide</i></p><blockquote><h3>Data :maillon $* liste$;</h3><h3>Result : boolean $isVide$</h3><h3>if &nbsp;$liste=Null$ then</h3><h3>return $vrai$;</h3><h3>end if</h3><h3>return $faux$;</h3></blockquote><p><strong>Algorithm 24&nbsp;:&nbsp;</strong><i>Algorithme : Langueur d’une liste chaînée&nbsp;</i></p><blockquote><h3>Data :maillon $* liste$;</h3><h3>Result : int&nbsp;$longueur$</h3><h3>if &nbsp;$liste = Nul$ then</h3><h3>return $0$;</h3><h3>else</h3><h3>return $1+LongueurListe(Queue(liste))$;</h3><h3>end if</h3></blockquote><p><i><strong>Remarque 2.4.5</strong></i></p><blockquote><p>1 La complexitéde l’algorithme est $O(Longeur de la liste)$.</p><p>2 Une version itérative est possible en remplaçant l’appel récursif par une boucle while.</p></blockquote><p>&nbsp;Cet algorithme permet d’ajouter un élément à la ﬁn de la liste.</p><p><strong>Algorithm 25&nbsp;:&nbsp;</strong><i>Algorithme : Ajout d’une valeur à la ﬁn d’une liste chaînée&nbsp;&nbsp;</i></p><blockquote><h3>Data : maillon $* liste$, int $x$</h3><h3>Var maillon $*temp$;</h3><h3>if &nbsp;$liste = Nul$ then</h3><h3>$Cons(x, liste)$;</h3><h3>else</h3><h3>$Temp ← liste.suivant$;</h3><h3>while $Temp&nbsp;≠&nbsp;NIL$ do</h3><h3>$Temp ← Temp.suivant$</h3><h3>end while</h3><h3>$Cons(x, Temp)$</h3><h3>end if</h3></blockquote><p><i><strong>Remarque 2.4.6</strong></i></p><blockquote><p>1 Pour ajouter une valeur à la ﬁn de la liste, il faut d’abord parcourir la liste.</p><p>2 La complexité de l’algorithme est $O(Longueur de la liste)$.</p></blockquote><p>Cet algorithme élimine un élément de la liste chaînée.<br><br>&nbsp;</p><p><strong>Algorithm 26&nbsp;:&nbsp;</strong><i>Algorithme : Suppression d’une valeur d’une liste chaînée&nbsp;&nbsp;</i></p><blockquote><h3>Data : maillon $* liste$, int $x$</h3><h3>Result : boolean $isExist$</h3><h3>Var maillon $* temp$;</h3><h3>if &nbsp;$liste = Nul$ then</h3><h3>return $faux$;</h3><h3>else</h3><h3>$Temp ← liste.suivant$</h3><h3>while $Temp ≠&nbsp;NIL$ do</h3><h3>if &nbsp;$Temp.valeur = x$ then</h3><h3>$Temp.suivant ← Temp.suivant.suivant$;</h3><h3>return $vrai$;</h3><h3>else</h3><h3>$Temp ← Temp.suivant$</h3><h3>end if</h3><h3>end while</h3><h3>return $faux$;</h3><h3>end if</h3></blockquote><p><i><strong>Remarque 2.4.7</strong></i></p><blockquote><p>1 Pour supprimer une valeur de la liste, il faut d’abord parcourir la liste jus-qu’on trouve l’élément. Si l’élément est trouvé : On supprime le maillon de la liste.</p><p>2 La complexitéde l’algorithme estO( Longueur de la liste).</p></blockquote><p>2.4.4 Liste doublement chaînée</p><p>Le principe d’une liste doublement chaînée est d’avoir deux pointeurs dans un maillon vers :</p><p style=\"margin-left:40px;\">— La cellule suivante</p><p style=\"margin-left:40px;\">— La cellule précédente</p><p><i><strong>Deﬁnition 2.4.8</strong></i></p><blockquote><p>Une liste doublement chainée est une liste pour laquelle les opérations en temps $O(1)$ sont celles des listes simplement chaînées auxquelles on ajoute les fonctions d’accès :</p><p style=\"margin-left:40px;\">— fonction ﬁnListe(val L : liste d’objet) : vide : positionne la clé sur le dernier objet de la liste</p><p style=\"margin-left:40px;\">— fonction précédent(val L : liste d’objet) : vide; : recule la clé d’une position dans la liste</p></blockquote><p>&nbsp;2.4.5 Conclusion</p><p>Chaque structure de donnée a ses avantages et ses inconvénients. Pour bien comprendre l’intérêt de chaque structure de donnée, nous présentons une comparaison entre un tableau et une liste chainée.</p><p><strong>Les avantages d’un tableau sont :</strong></p><p style=\"margin-left:40px;\">— La taille du tableau est connue.</p><p style=\"margin-left:40px;\">— L’adresse du premier élément est connue aussi.</p><p style=\"margin-left:40px;\">— Il est possible d’atteindre directement la case $i$ du tableau.</p><p><strong>Les inconvénient d’un tableau sont :</strong></p><p style=\"margin-left:40px;\">— Pour déclarer le tableau, il faut connaître sa taille.</p><p style=\"margin-left:40px;\">— Pour supprimer ou ajouter un élément à un tableau, il faut créer un nouveau tableau et supprimer l’ancien.</p><p><strong>Les avantages d’une liste chaînée sont :</strong></p><p style=\"margin-left:40px;\">— La liste peut avoir autant d’éléments que la mémoire le permet.</p><p style=\"margin-left:40px;\">— Pour déclarer une liste chaînée, il sufﬁt de créer le pointeur qui va pointer sur le premier élément de la liste.</p><p style=\"margin-left:40px;\">— Aucune taille n’est donc à spéciﬁer.</p><p style=\"margin-left:40px;\">— Il est possible d’ajouter, de supprimer, d’intervertir des éléments d’une liste chaînée sans avoir à recréer la liste en entier, mais en manipulant simplement leurs pointeurs.</p><p><strong>Les inconvénients d’une liste chaînée sont :</strong></p><p style=\"margin-left:40px;\">— Il est impossible d’accéder directement à l’élément $i$ de la liste.</p><p style=\"margin-left:40px;\">— Il faut traverser les $i−1$ éléments précédents de la liste.</p>",
          "idOnglet": 1
        }
      ]
    }
  ]
}